<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Energy Data (with Battery)</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
  <!-- Chart.js from CDN (4.x) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.2.1"></script>
</head>
<body>
<div class="container">
  <h1>Energy Data Viewer (with Battery)</h1>

  <!-- Default Tariff with Charge/Discharge Toggle -->
  <div style="margin-bottom: 20px;">
    <label for="defaultTariffPrice">Default Tariff (pence/kWh):</label>
    <input type="number" id="defaultTariffPrice" value="30.00" step="0.01" style="width:80px;" />
    <label style="margin-left: 1em;">Mode:</label>
    <select id="defaultTariffMode">
      <option value="charge">Charge Battery</option>
      <option value="discharge" selected>Discharge Battery</option>
    </select>
  </div>

  <!-- Battery Capacity (kWh) -->
  <div style="margin-bottom: 20px;">
    <label for="batteryCapacity">Battery Capacity (kWh, optional):</label>
    <input type="number" id="batteryCapacity" value="0" step="0.1" style="width:80px;" />
    <p style="font-size: 0.9em; color: #444;">If 0 or blank, battery logic is disabled.</p>
  </div>

  <!-- Special Tariffs Table (Time of Day, Charge/Discharge, Price) -->
  <div class="tariff-table-section">
    <button id="toggleTariffTableBtn">Show/Hide Special Tariffs</button>
    <div id="tariffTableContainer" style="display:none; margin-top: 1em;">
      <h2>Special Tariffs (Every Day at These Times)</h2>
      <table id="tariffTable">
        <thead>
          <tr>
            <th>Start Time (HH:MM)</th>
            <th>Until Time (HH:MM)</th>
            <th>Mode</th>
            <th>Price (pence/kWh)</th>
            <th>Remove?</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows appended dynamically -->
        </tbody>
      </table>
      <button id="addTariffRowBtn">Add Row</button>
      <p class="overlap-warning" id="overlapWarning" style="display:none; color:red; font-weight:bold;">
        Overlapping special tariff entries found! Please fix them.
      </p>
      <p style="font-size: 0.9em; color: #444;">
        Note: If multiple special tariffs match the same time, the first in the table has priority.
      </p>
    </div>
  </div>

  <!-- View Mode: Price or Consumption -->
  <div style="margin-bottom: 20px;">
    <strong>View Mode:</strong><br/>
    <label><input type="radio" name="viewMode" value="cost" checked/>Price</label>
    <label><input type="radio" name="viewMode" value="consumption"/>Consumption</label>
  </div>

  <!-- Period Selector -->
  <div style="margin-bottom: 20px;">
    <label for="periodSelect">Aggregation Period:</label>
    <select id="periodSelect">
      <option value="30min">30 minutes</option>
      <option value="1h">1 hour</option>
      <option value="1d">1 day</option>
      <option value="1M">1 month</option>
      <option value="1y">1 year</option>
    </select>
  </div>

  <!-- Navigation (previous/next) -->
  <div class="navigation-controls">
    <button id="prevBtn">&larr; Previous</button>
    <span id="navLabel"></span>
    <button id="nextBtn">Next &rarr;</button>
  </div>

  <!-- Chart 1: Raw Aggregation (no battery) -->
  <canvas id="myChartRaw" width="800" height="400"></canvas>

  <!-- Chart 2: Battery-Adjusted Aggregation -->
  <h2>Battery-Adjusted Data</h2>
  <canvas id="myChartBattery" width="800" height="400"></canvas>
</div>

<script>
/***********************************************************************
 * Global Variables
 ***********************************************************************/
let halfHourData = []; // array of {startEpoch, endEpoch, kWh, startDateTime, endDateTime}
let myChartRaw = null;      // Chart.js instance for raw data
let myChartBattery = null;  // Chart.js instance for battery data

// We keep a "currentDate" in full resolution. The aggregator just picks
// the relevant day/month/year from this underlying date.
let currentDate = null;
let currentPeriod = '30min';     // '30min','1h','1d','1M','1y'
let currentViewMode = 'cost';    // 'cost' or 'consumption'

// Default Tariff
let defaultTariff = {
  pricePence: 30.00,
  mode: 'discharge' // or 'charge'
};

// Battery capacity (kWh)
let batteryCapacity = 0.0;

// Special Tariffs: array of objects like
// {
//   startTime: "HH:MM",
//   endTime:   "HH:MM",
//   mode:      "charge" or "discharge",
//   pricePence: number
// }
// We apply these every day. If multiple match, the first row wins.
let specialTariffs = [];

/***********************************************************************
 * On Window Load
 ***********************************************************************/
window.addEventListener('load', async () => {
  // 1. Fetch half-hour data from server
  const resp = await fetch('/data');
  halfHourData = await resp.json();

  // 2. If we have data, set currentDate to earliest record
  if (halfHourData.length > 0) {
    currentDate = new Date(halfHourData[0].startDateTime);
  } else {
    currentDate = new Date(); // fallback
  }

  // 3. Init the two charts
  initCharts();

  // 4. Attach event listeners
  document.getElementById('periodSelect').addEventListener('change', onPeriodChange);
  document.getElementById('prevBtn').addEventListener('click', () => shiftView(-1));
  document.getElementById('nextBtn').addEventListener('click', () => shiftView(1));

  // View Mode radio
  document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
    radio.addEventListener('change', e => {
      currentViewMode = e.target.value; // 'cost' or 'consumption'
      refreshAllCharts();
    });
  });

  // Default Tariff
  document.getElementById('defaultTariffPrice').addEventListener('change', updateDefaultTariff);
  document.getElementById('defaultTariffMode').addEventListener('change', updateDefaultTariff);

  // Battery
  document.getElementById('batteryCapacity').addEventListener('change', updateBatteryCapacity);

  // Tariff table
  document.getElementById('toggleTariffTableBtn').addEventListener('click', toggleTariffTable);
  document.getElementById('addTariffRowBtn').addEventListener('click', addTariffRow);

  // 5. Render
  refreshAllCharts();
});

/***********************************************************************
 * Init the Two Charts
 ***********************************************************************/
function initCharts() {
  // Chart 1: Raw data
  const ctx1 = document.getElementById('myChartRaw').getContext('2d');
  myChartRaw = new Chart(ctx1, {
    type: 'bar',
    data: { labels: [], datasets: [{ label:'', data:[] }] },
    options: {
      // As requested, comment out "responsive" and "maintainAspectRatio"
      // responsive: true,
      // maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: { display: true, text: '' }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: function(context) {
              let val = context.parsed.y;
              if (currentViewMode === 'cost') {
                return '£' + val.toFixed(2);
              } else {
                return val.toFixed(3) + ' kWh';
              }
            }
          }
        }
      }
    }
  });

  // Chart 2: Battery data
  const ctx2 = document.getElementById('myChartBattery').getContext('2d');
  myChartBattery = new Chart(ctx2, {
    data: {
      labels: [],
      datasets: [
        {
          type: 'bar',
          label: '', // We'll set dynamically
          data: []
        },
        {
          // We'll use a line dataset for Battery SoC in 30min or 1h modes only
          type: 'line',
          label: 'Battery SoC (kWh)',
          data: [],
          yAxisID: 'y2',  // second axis
          hidden: false // We'll hide/show it programmatically
        }
      ]
    },
    options: {
      // responsive: true,
      // maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: { display: true, text: '' }
        },
        y2: {
          beginAtZero: true,
          position: 'right',
          title: { display: true, text: 'Battery SoC (kWh)' },
          grid: { drawOnChartArea: false } // keep lines separate
        }
      },
      plugins: {
        legend: { display: true }, // show both bar & line in legend
        tooltip: {
          callbacks: {
            label: function(context) {
              let val = context.parsed.y;
              // Are we on the bar dataset (0) or the line dataset (1)?
              if (context.datasetIndex === 0) {
                // It's usage or cost
                if (currentViewMode === 'cost') {
                  return '£' + val.toFixed(2);
                } else {
                  return val.toFixed(3) + ' kWh';
                }
              } else {
                // It's battery SoC
                return val.toFixed(2) + ' kWh';
              }
            }
          }
        }
      }
    }
  });
}

/***********************************************************************
 * Refresh Both Charts
 ***********************************************************************/
function refreshAllCharts() {
  // Re-read user inputs
  readTariffTable();   // updates specialTariffs array
  // Then rebuild aggregator data & update chart #1 (raw) and #2 (battery).

  // #1: Raw aggregator
  let { labels:rawLabels, values:rawVals } = buildRawAggregatedData();
  updateChartRaw(rawLabels, rawVals);

  // #2: Battery aggregator
  let batteryResult = buildBatteryAggregatedData();
  updateChartBattery(batteryResult);
}

/***********************************************************************
 * Raw Aggregation (No Battery)
 ***********************************************************************/
function buildRawAggregatedData() {
  // This aggregator is basically the same as prior examples:
  // - We take the relevant time window (day, month, year, etc.)
  // - Sum usage or cost

  if (!currentDate) {
    return { labels:[], values:[] };
  }

  switch (currentPeriod) {
    case '30min':
    case '1h':
      return buildRawHourlyOrHalfHourly(currentPeriod);
    case '1d':
      return buildRawDaily();
    case '1M':
      return buildRawMonthly();
    case '1y':
      return buildRawYearly();
    default:
      return { labels:[], values:[] };
  }
}

function buildRawHourlyOrHalfHourly(period) {
  // Show the entire day for currentDate
  let dayStart = new Date(currentDate);
  dayStart.setUTCHours(0,0,0,0);
  let dayEnd = new Date(dayStart);
  dayEnd.setUTCDate(dayEnd.getUTCDate() + 1);

  document.getElementById('navLabel').innerText = dayStart.toISOString().slice(0,10);

  let dayStartSec = dayStart.getTime()/1000;
  let dayEndSec   = dayEnd.getTime()/1000;
  let intervals = halfHourData.filter(d => d.endEpoch > dayStartSec && d.startEpoch < dayEndSec);

  let binSize = (period === '30min') ? 1800 : 3600;
  let labels = [];
  let values = [];

  let t = dayStartSec;
  while (t < dayEndSec) {
    let binStart = t;
    let binEnd   = t + binSize;
    let labelStr = formatHourMinute(new Date(binStart*1000)) + "-" +
                   formatHourMinute(new Date(binEnd*1000));

    let val = 0.0;
    if (currentViewMode === 'cost') {
      val = sumCostForRange(binStart, binEnd, intervals);
    } else {
      val = sumConsumptionForRange(binStart, binEnd, intervals);
    }

    labels.push(labelStr);
    values.push(val);
    t += binSize;
  }

  return { labels, values };
}

function buildRawDaily() {
  // Show the month containing currentDate
  let dt = new Date(currentDate);
  let mStart = new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), 1));
  let mEnd   = new Date(mStart);
  mEnd.setUTCMonth(mEnd.getUTCMonth() + 1);

  document.getElementById('navLabel').innerText = mStart.toISOString().slice(0,7);

  let sSec = mStart.getTime()/1000;
  let eSec = mEnd.getTime()/1000;
  let intervals = halfHourData.filter(d => d.endEpoch > sSec && d.startEpoch < eSec);

  let labels = [];
  let values = [];
  let cursor = new Date(mStart);
  while (cursor < mEnd) {
    let dayS = new Date(cursor);
    let dayE = new Date(cursor);
    dayE.setUTCDate(dayE.getUTCDate() + 1);

    let dsSec = dayS.getTime()/1000;
    let deSec = dayE.getTime()/1000;

    let labelStr = dayS.toISOString().slice(0,10);
    let val = 0.0;
    if (currentViewMode === 'cost') {
      val = sumCostForRange(dsSec, deSec, intervals);
    } else {
      val = sumConsumptionForRange(dsSec, deSec, intervals);
    }

    labels.push(labelStr);
    values.push(val);

    cursor.setUTCDate(cursor.getUTCDate() + 1);
  }
  return { labels, values };
}

function buildRawMonthly() {
  // Show the year containing currentDate
  let dt = new Date(currentDate);
  let year = dt.getUTCFullYear();

  let yearStart = new Date(Date.UTC(year, 0, 1));
  let nextYear  = new Date(Date.UTC(year+1, 0, 1));

  document.getElementById('navLabel').innerText = year.toString();

  let sSec = yearStart.getTime()/1000;
  let eSec = nextYear.getTime()/1000;
  let intervals = halfHourData.filter(d => d.endEpoch > sSec && d.startEpoch < eSec);

  let labels = [];
  let values = [];

  let cursor = new Date(yearStart);
  for (let m=0; m<12; m++) {
    let mS = new Date(cursor);
    let mE = new Date(cursor);
    mE.setUTCMonth(mE.getUTCMonth() + 1);

    let msSec = mS.getTime()/1000;
    let meSec = mE.getTime()/1000;

    let labelStr = mS.toISOString().slice(0,7);

    let val = 0.0;
    if (currentViewMode === 'cost') {
      val = sumCostForRange(msSec, meSec, intervals);
    } else {
      val = sumConsumptionForRange(msSec, meSec, intervals);
    }

    labels.push(labelStr);
    values.push(val);

    cursor.setUTCMonth(cursor.getUTCMonth() + 1);
  }
  return { labels, values };
}

function buildRawYearly() {
  // Show all years in the data
  if (halfHourData.length === 0) {
    return { labels:[], values:[] };
  }

  let earliest = new Date(halfHourData[0].startDateTime);
  let latest   = new Date(halfHourData[halfHourData.length-1].startDateTime);
  let earliestY = earliest.getUTCFullYear();
  let latestY   = latest.getUTCFullYear();

  document.getElementById('navLabel').innerText = earliestY + " - " + latestY;

  let globalEarliestSec = halfHourData[0].startEpoch;
  let globalLatestSec   = halfHourData[halfHourData.length-1].endEpoch;

  let labels = [];
  let values = [];
  for (let y=earliestY; y<=latestY; y++) {
    let yS = Date.UTC(y,0,1,0,0,0);
    let yE = Date.UTC(y+1,0,1,0,0,0);

    let intervals = halfHourData.filter(d => d.endEpoch > (yS/1000) && d.startEpoch < (yE/1000));
    let val = 0.0;
    if (currentViewMode === 'cost') {
      val = sumCostForRange(yS/1000, yE/1000, intervals);
    } else {
      val = sumConsumptionForRange(yS/1000, yE/1000, intervals);
    }

    let labelStr = y.toString();
    // Mark incomplete if it doesn't fully cover the year
    if (globalEarliestSec > (yS/1000) || globalLatestSec < (yE/1000)) {
      labelStr += " (Incomplete)";
    }

    labels.push(labelStr);
    values.push(val);
  }
  return { labels, values };
}

/***********************************************************************
 * Battery-Aware Aggregation
 ***********************************************************************/
function buildBatteryAggregatedData() {
  // We want the same aggregator structure (30min, 1h, 1d, 1M, 1y),
  // but the usage or cost is adjusted by simulated battery usage.

  // 1. If batteryCapacity <= 0, there's effectively no battery usage
  //    => same as raw aggregator.
  if (batteryCapacity <= 0) {
    // Just mimic raw aggregator
    let raw = buildRawAggregatedData();
    return {
      labels: raw.labels,
      values: raw.values,
      batteryLine: [] // empty or zero
    };
  }

  // 2. We first run a "battery simulation" for each 30-min block in chronological order,
  //    storing the resulting battery SoC and the "net usage from grid" for that block.
  let batterySim = simulateBatteryOverAllData();

  // 3. Then we do the aggregator exactly the same way, but we sum the "net usage" from
  //    batterySim instead of the original "kWh" for each block. For cost, we multiply
  //    net usage by the block’s tariff price, same as sumCostForRange but referencing
  //    the batterySim usage & price. Meanwhile, we also capture the battery SoC
  //    for 30-min or 1h bins (to plot as a line).

  return aggregateBatteryData(batterySim);
}

function simulateBatteryOverAllData() {
  // We'll produce an array the same length as halfHourData,
  // each element => { netGridUsage: number, batterySoC: number, startEpoch:..., endEpoch:..., pricePence:..., mode:... }
  // We must determine the price & mode for each block from the time-of-day tariffs or default.

  let sim = [];
  let currentSoC = 0.0;

  // Sort halfHourData by ascending startEpoch
  let sorted = halfHourData.slice().sort((a,b)=> a.startEpoch - b.startEpoch);

  for (let i=0; i<sorted.length; i++) {
    let block = sorted[i];
    let usageKwh = block.kWh; // original usage
    // Determine which tariff applies (time-of-day check)
    let { pricePence, mode } = findTariffForBlock(block);

    let netGridUsage = usageKwh;
    if (mode === 'charge') {
      // Battery can charge up to 1.5 kWh in 30 min
      // The actual charge = min(1.5, batteryCapacity - currentSoC)
      let canCharge = Math.min(1.5, batteryCapacity - currentSoC);
      if (canCharge > 0) {
        // This extra charge is added to net usage from the grid
        netGridUsage = usageKwh + canCharge;
        currentSoC += canCharge; // battery increases
      } else {
        // Battery is full, no extra usage
        netGridUsage = usageKwh;
      }
    } else if (mode === 'discharge') {
      // Battery supplies up to usageKwh
      let canSupply = Math.min(currentSoC, usageKwh);
      let net = usageKwh - canSupply;
      netGridUsage = net;
      currentSoC -= canSupply; // battery goes down
    }

    sim.push({
      startEpoch: block.startEpoch,
      endEpoch:   block.endEpoch,
      originalKwh: usageKwh,
      netGridUsage: netGridUsage,
      batterySoC: currentSoC,
      tariffPence: pricePence,
      tariffMode: mode
    });
  }

  return sim;
}

function findTariffForBlock(block) {
  // block has startEpoch, etc. We'll find the local time-of-day in UTC,
  // e.g. "HH:MM" for block.startEpoch. Then check each specialTariff in order,
  // see if we fall within [startTime, endTime], if so, use that tariff.
  // Otherwise, fall back to default.
  // If multiple special tariffs match, the first row in the table takes priority.

  let dt = new Date(block.startEpoch*1000);
  let hh = dt.getUTCHours();
  let mm = dt.getUTCMinutes();
  let blockMinutes = hh*60 + mm; // minutes after midnight

  for (let st of specialTariffs) {
    let [sh, sm] = st.startTime.split(':').map(x=> parseInt(x,10));
    let [eh, em] = st.endTime.split(':').map(x=> parseInt(x,10));
    let startMin = sh*60 + sm;
    let endMin   = eh*60 + em;
    // We say "if blockMinutes in [startMin, endMin)"
    // But we must handle if endMin < startMin => "wraps midnight"? (not specified),
    // We'll assume user doesn't do that. If needed, you'd handle that specially.

    if (blockMinutes >= startMin && blockMinutes < endMin) {
      return { pricePence: st.pricePence, mode: st.mode };
    }
  }
  // Not in any special tariff => default
  return { pricePence: defaultTariff.pricePence, mode: defaultTariff.mode };
}

function aggregateBatteryData(batterySim) {
  // We'll do a near copy of the aggregator logic, except we reference "netGridUsage"
  // from batterySim and "tariffPence" to compute cost. We also want to store the SoC
  // for each block in case we want to plot it in 30-min or 1-hour mode.

  let aggregatorResult = { labels:[], values:[], batteryLine:[] };

  if (!currentDate || batterySim.length===0) {
    return aggregatorResult;
  }

  switch (currentPeriod) {
    case '30min':
    case '1h':
      aggregatorResult = batteryAggHourlyOrHalfHourly(batterySim, currentPeriod);
      break;
    case '1d':
      aggregatorResult = batteryAggDaily(batterySim);
      break;
    case '1M':
      aggregatorResult = batteryAggMonthly(batterySim);
      break;
    case '1y':
      aggregatorResult = batteryAggYearly(batterySim);
      break;
  }
  return aggregatorResult;
}

function batteryAggHourlyOrHalfHourly(sim, period) {
  // Show the entire day for currentDate
  let dayStart = new Date(currentDate);
  dayStart.setUTCHours(0,0,0,0);
  let dayEnd = new Date(dayStart);
  dayEnd.setUTCDate(dayEnd.getUTCDate()+1);

  let dayStartSec = dayStart.getTime()/1000;
  let dayEndSec   = dayEnd.getTime()/1000;
  document.getElementById('navLabel').innerText = dayStart.toISOString().slice(0,10);

  // Filter sim to that day
  let dayBlocks = sim.filter(d => d.endEpoch > dayStartSec && d.startEpoch < dayEndSec);

  let binSize = (period === '30min') ? 1800 : 3600;
  let labels = [];
  let values = [];
  let batteryLine = []; // We'll store a single SoC value per bin

  let t = dayStartSec;
  while (t < dayEndSec) {
    let binStart = t;
    let binEnd   = t + binSize;
    let labelStr = formatHourMinute(new Date(binStart*1000)) + "-" +
                   formatHourMinute(new Date(binEnd*1000));

    // Gather blocks in [binStart, binEnd)
    let blocksInBin = dayBlocks.filter(b => b.endEpoch>binStart && b.startEpoch<binEnd);

    // We sum either cost or consumption across these blocks
    let sumVal = 0.0;
    let sumSoC = 0.0; // We'll average or just take last SoC in this bin
    let count  = 0;

    for (let b of blocksInBin) {
      let overlapStart = Math.max(binStart, b.startEpoch);
      let overlapEnd   = Math.min(binEnd, b.endEpoch);
      let fraction     = (overlapEnd - overlapStart)/(b.endEpoch - b.startEpoch);
      if (fraction<=0) continue;

      if (currentViewMode === 'cost') {
        // cost = netGridUsage * price / 100
        sumVal += (b.netGridUsage * fraction) * (b.tariffPence/100.0);
      } else {
        // consumption
        sumVal += (b.netGridUsage * fraction);
      }
      sumSoC += b.batterySoC; // or track last SoC? We'll do an average
      count++;
    }
    if (count>0) {
      batteryLine.push(sumSoC/count);
    } else {
      batteryLine.push(0);
    }

    labels.push(labelStr);
    values.push(sumVal);

    t+= binSize;
  }

  return { labels, values, batteryLine };
}

function batteryAggDaily(sim) {
  let dt = new Date(currentDate);
  let mStart = new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(),1));
  let mEnd   = new Date(mStart);
  mEnd.setUTCMonth(mEnd.getUTCMonth()+1);

  document.getElementById('navLabel').innerText = mStart.toISOString().slice(0,7);

  let sSec = mStart.getTime()/1000;
  let eSec = mEnd.getTime()/1000;
  let monthBlocks = sim.filter(d => d.endEpoch> sSec && d.startEpoch< eSec);

  let labels = [];
  let values = [];
  let batteryLine = [];

  let cursor = new Date(mStart);
  while (cursor < mEnd) {
    let dayS = new Date(cursor);
    let dayE = new Date(cursor);
    dayE.setUTCDate(dayE.getUTCDate()+1);

    let dsSec = dayS.getTime()/1000;
    let deSec = dayE.getTime()/1000;

    let dayBlocks = monthBlocks.filter(d => d.endEpoch>dsSec && d.startEpoch<deSec);

    let val=0.0, totalSoC=0.0, count=0;
    for (let b of dayBlocks) {
      let overlapStart = Math.max(dsSec, b.startEpoch);
      let overlapEnd   = Math.min(deSec, b.endEpoch);
      let fraction = (overlapEnd - overlapStart)/(b.endEpoch - b.startEpoch);
      if (fraction>0) {
        if (currentViewMode==='cost') {
          val += (b.netGridUsage*fraction)*(b.tariffPence/100.0);
        } else {
          val += (b.netGridUsage*fraction);
        }
        totalSoC += b.batterySoC;
        count++;
      }
    }

    let labelStr = dayS.toISOString().slice(0,10);
    labels.push(labelStr);
    values.push(val);
    batteryLine.push(count>0 ? (totalSoC/count) : 0);

    cursor.setUTCDate(cursor.getUTCDate()+1);
  }

  return { labels, values, batteryLine };
}

function batteryAggMonthly(sim) {
  let dt = new Date(currentDate);
  let year = dt.getUTCFullYear();
  let yStart = new Date(Date.UTC(year,0,1));
  let yEnd   = new Date(Date.UTC(year+1,0,1));

  document.getElementById('navLabel').innerText = year.toString();

  let sSec = yStart.getTime()/1000;
  let eSec = yEnd.getTime()/1000;
  let yearBlocks = sim.filter(d => d.endEpoch> sSec && d.startEpoch< eSec);

  let labels = [];
  let values = [];
  let batteryLine = [];

  let cursor = new Date(yStart);
  for (let m=0; m<12; m++) {
    let mS = new Date(cursor);
    let mE = new Date(cursor);
    mE.setUTCMonth(mE.getUTCMonth()+1);

    let msSec = mS.getTime()/1000;
    let meSec = mE.getTime()/1000;

    let blocks = yearBlocks.filter(d => d.endEpoch>msSec && d.startEpoch<meSec);

    let val=0.0, totalSoC=0.0, count=0;
    for (let b of blocks) {
      let overlapStart = Math.max(msSec, b.startEpoch);
      let overlapEnd   = Math.min(meSec, b.endEpoch);
      let fraction = (overlapEnd - overlapStart)/(b.endEpoch - b.startEpoch);
      if (fraction>0) {
        if (currentViewMode==='cost') {
          val += (b.netGridUsage*fraction)*(b.tariffPence/100.0);
        } else {
          val += (b.netGridUsage*fraction);
        }
        totalSoC+=b.batterySoC;
        count++;
      }
    }

    let labelStr = mS.toISOString().slice(0,7);
    labels.push(labelStr);
    values.push(val);
    batteryLine.push(count>0?(totalSoC/count):0);

    cursor.setUTCMonth(cursor.getUTCMonth()+1);
  }

  return { labels, values, batteryLine };
}

function batteryAggYearly(sim) {
  // Show all years in data
  if (sim.length===0) return { labels:[], values:[], batteryLine:[] };

  let sorted = sim.slice().sort((a,b)=>a.startEpoch - b.startEpoch);
  let earliest = sorted[0].startEpoch;
  let latest   = sorted[sorted.length-1].endEpoch;
  let earliestDt = new Date(earliest*1000);
  let latestDt   = new Date(latest*1000);
  let earliestY = earliestDt.getUTCFullYear();
  let latestY   = latestDt.getUTCFullYear();

  document.getElementById('navLabel').innerText = earliestY + " - " + latestY;

  let labels = [];
  let values = [];
  let batteryLine = [];

  for (let y=earliestY; y<=latestY; y++) {
    let yS = Date.UTC(y,0,1);
    let yE = Date.UTC(y+1,0,1);

    let blocks = sim.filter(d => d.endEpoch>(yS/1000) && d.startEpoch<(yE/1000));

    let val=0.0, totalSoC=0.0, count=0;
    for (let b of blocks) {
      let overlapStart = Math.max(yS/1000, b.startEpoch);
      let overlapEnd   = Math.min(yE/1000, b.endEpoch);
      let fraction = (overlapEnd - overlapStart)/(b.endEpoch - b.startEpoch);
      if (fraction>0) {
        if (currentViewMode==='cost') {
          val += (b.netGridUsage*fraction)*(b.tariffPence/100.0);
        } else {
          val += (b.netGridUsage*fraction);
        }
        totalSoC+=b.batterySoC;
        count++;
      }
    }
    let labelStr = y.toString();
    labels.push(labelStr);
    values.push(val);
    batteryLine.push(count>0?(totalSoC/count):0);
  }

  return { labels, values, batteryLine };
}

/***********************************************************************
 * Update Chart 1 (Raw)
 ***********************************************************************/
function updateChartRaw(labels, values) {
  // Update dataset & label
  myChartRaw.data.labels = labels;
  myChartRaw.data.datasets[0].data = values;
  if (currentViewMode==='cost') {
    myChartRaw.data.datasets[0].label = 'Cost (£)';
    myChartRaw.options.scales.y.title.text = 'Cost in GBP';
  } else {
    myChartRaw.data.datasets[0].label = 'Consumption (kWh)';
    myChartRaw.options.scales.y.title.text = 'Consumption (kWh)';
  }
  myChartRaw.update();
}

/***********************************************************************
 * Update Chart 2 (Battery)
 ***********************************************************************/
function updateChartBattery({ labels, values, batteryLine }) {
  // Bar data
  myChartBattery.data.labels = labels;
  myChartBattery.data.datasets[0].data = values;

  // Hide or show the battery line for 30min/1h only
  if (currentPeriod==='30min' || currentPeriod==='1h') {
    myChartBattery.data.datasets[1].hidden = false;
    myChartBattery.data.datasets[1].data = batteryLine;
  } else {
    // For daily, monthly, yearly => no line
    myChartBattery.data.datasets[1].hidden = true;
    myChartBattery.data.datasets[1].data = [];
  }

  // Adjust axes label
  if (currentViewMode==='cost') {
    myChartBattery.data.datasets[0].label = 'Cost (£)';
    myChartBattery.options.scales.y.title.text = 'Cost in GBP';
  } else {
    myChartBattery.data.datasets[0].label = 'Consumption (kWh)';
    myChartBattery.options.scales.y.title.text = 'Consumption (kWh)';
  }

  myChartBattery.update();
}

/***********************************************************************
 * Summation Helpers (Raw)
 ***********************************************************************/
function sumConsumptionForRange(rangeStartSec, rangeEndSec, intervals) {
  let total = 0.0;
  for (let blk of intervals) {
    let overlapStart = Math.max(rangeStartSec, blk.startEpoch);
    let overlapEnd   = Math.min(rangeEndSec, blk.endEpoch);
    let fraction     = (overlapEnd - overlapStart)/(blk.endEpoch - blk.startEpoch);
    if (fraction>0) {
      total += (blk.kWh * fraction);
    }
  }
  return total;
}

function sumCostForRange(rangeStartSec, rangeEndSec, intervals) {
  // Because we have a single default price in the raw aggregator (no battery logic),
  // we can do "price = findTariffForTimeOfDay(...)" for each block portion. That
  // duplicates the old logic. But for brevity, let's assume a single defaultTariff
  // for raw aggregator, ignoring the time-of-day special tariffs from the table.
  // 
  // If you want the raw aggregator to also incorporate special tariff prices, do
  // something similar to "findTariffForBlock" for each sub-interval. 
  // But let's keep it simpler: we treat "raw aggregator" as if only the default price
  // is used. If you want raw aggregator to also reflect special tariffs, you can do it
  // with additional logic here.

  let pricePence = defaultTariff.pricePence; // ignoring special tariffs
  let totalCost = 0.0;
  for (let blk of intervals) {
    let overlapStart = Math.max(rangeStartSec, blk.startEpoch);
    let overlapEnd   = Math.min(rangeEndSec, blk.endEpoch);
    let fraction = (overlapEnd - overlapStart)/(blk.endEpoch - blk.startEpoch);
    if (fraction>0) {
      totalCost += (blk.kWh*fraction)*(pricePence/100.0);
    }
  }
  return totalCost;
}

/***********************************************************************
 * Next/Previous
 ***********************************************************************/
function shiftView(direction) {
  // direction: +1 or -1
  switch (currentPeriod) {
    case '30min':
    case '1h':
      currentDate.setUTCDate(currentDate.getUTCDate() + direction);
      break;
    case '1d':
      currentDate.setUTCMonth(currentDate.getUTCMonth() + direction);
      break;
    case '1M':
      currentDate.setUTCFullYear(currentDate.getUTCFullYear() + direction);
      break;
    case '1y':
      currentDate.setUTCFullYear(currentDate.getUTCFullYear() + direction);
      break;
  }
  refreshAllCharts();
}

function onPeriodChange() {
  currentPeriod = document.getElementById('periodSelect').value;
  refreshAllCharts();
}

/***********************************************************************
 * Tariff Table
 ***********************************************************************/
function toggleTariffTable() {
  const c = document.getElementById('tariffTableContainer');
  c.style.display = (c.style.display==='none') ? 'block' : 'none';
}

function addTariffRow() {
  let tbody = document.querySelector('#tariffTable tbody');
  let row = document.createElement('tr');

  // Start time
  let td1 = document.createElement('td');
  let inp1 = document.createElement('input');
  inp1.type='time';  // <--- Only time (HH:MM)
  inp1.value='08:00';
  td1.appendChild(inp1);

  // End time
  let td2 = document.createElement('td');
  let inp2 = document.createElement('input');
  inp2.type='time';
  inp2.value='10:00';
  td2.appendChild(inp2);

  // Mode
  let td3 = document.createElement('td');
  let sel3 = document.createElement('select');
  let optCharge = new Option('Charge','charge');
  let optDisch  = new Option('Discharge','discharge');
  sel3.add(optCharge); sel3.add(optDisch);
  td3.appendChild(sel3);

  // Price
  let td4 = document.createElement('td');
  let inp4 = document.createElement('input');
  inp4.type='number';
  inp4.step='0.01';
  inp4.value='40.00';
  td4.appendChild(inp4);

  // Remove
  let td5 = document.createElement('td');
  let btn5 = document.createElement('button');
  btn5.textContent='Remove';
  btn5.addEventListener('click', ()=>{ row.remove(); refreshAllCharts(); });
  td5.appendChild(btn5);

  row.appendChild(td1);
  row.appendChild(td2);
  row.appendChild(td3);
  row.appendChild(td4);
  row.appendChild(td5);

  // On any change, refresh
  [inp1, inp2, sel3, inp4].forEach(el => {
    el.addEventListener('change', refreshAllCharts);
  });

  tbody.appendChild(row);
}

function readTariffTable() {
  specialTariffs = [];
  let rows = document.querySelectorAll('#tariffTable tbody tr');
  for (let r of rows) {
    let inputs = r.querySelectorAll('input,select');
    if (inputs.length<4) continue;
    let stVal = inputs[0].value; // "08:00"
    let enVal = inputs[1].value; // "10:00"
    let modeVal = inputs[2].value; // "charge" or "discharge"
    let priceVal = parseFloat(inputs[3].value);

    if (!stVal || !enVal || isNaN(priceVal)) continue;
    // You may want to check e.g. stVal < enVal, etc.
    specialTariffs.push({
      startTime: stVal,
      endTime: enVal,
      mode: modeVal,
      pricePence: priceVal
    });
  }
  // Check overlap
  let isOverlap = checkTariffOverlaps(specialTariffs);
  document.getElementById('overlapWarning').style.display = isOverlap ? 'block' : 'none';
}

function checkTariffOverlaps(tariffs) {
  // Sort them in the order they appear in the table => the first has priority
  // We'll do a naive check: if any two intervals intersect, it's an overlap.
  // start < end is a must. If start==end, skip or handle differently.
  for (let i=0; i<tariffs.length; i++) {
    let t1 = tariffs[i];
    let [sh1, sm1] = t1.startTime.split(':').map(Number);
    let [eh1, em1] = t1.endTime.split(':').map(Number);
    let start1 = sh1*60+sm1, end1 = eh1*60+em1;
    if (end1<start1) return true; // for simplicity, disallow wrap-midnight

    for (let j=i+1; j<tariffs.length; j++) {
      let t2 = tariffs[j];
      let [sh2, sm2] = t2.startTime.split(':').map(Number);
      let [eh2, em2] = t2.endTime.split(':').map(Number);
      let start2 = sh2*60+sm2, end2 = eh2*60+em2;
      if (end2<start2) return true; // also disallow wrap-midnight

      // Overlap if (start1<end2 && start2<end1)
      if (start1<end2 && start2<end1) {
        return true;
      }
    }
  }
  return false;
}

/***********************************************************************
 * Update Default Tariff, Battery
 ***********************************************************************/
function updateDefaultTariff() {
  let p = parseFloat(document.getElementById('defaultTariffPrice').value);
  if (isNaN(p) || p<0) p=30.0;
  defaultTariff.pricePence = p;

  let modeSel = document.getElementById('defaultTariffMode');
  defaultTariff.mode = modeSel.value; // 'charge' or 'discharge'

  refreshAllCharts();
}

function updateBatteryCapacity() {
  let c = parseFloat(document.getElementById('batteryCapacity').value);
  if (isNaN(c) || c<0) c=0;
  batteryCapacity = c;
  refreshAllCharts();
}

/***********************************************************************
 * Utility
 ***********************************************************************/
function formatHourMinute(dt) {
  let hh = dt.getUTCHours().toString().padStart(2,'0');
  let mm = dt.getUTCMinutes().toString().padStart(2,'0');
  return hh + ':' + mm;
}
</script>
</body>
</html>

